using Microsoft.AspNetCore.Components;

namespace Tavenem.Blazor.Framework;

/// <summary>
/// Provides semi-stable ID values for components
/// </summary>
public static class IdService
{
    private static readonly Dictionary<string, string> _typePrefixes = [];
    private static readonly Dictionary<string, string> _prefixTypes = [];
    private static readonly Dictionary<string, ulong> _prefixCount = [];

    /// <summary>
    /// Gets a semi-stable, reasonably unique ID values for components.
    /// </summary>
    /// <param name="component">The component for which to obtain an ID.</param>
    /// <returns>
    /// A string containing an ID suitable for use in an HTML <c>id</c> attribute.
    /// </returns>
    /// <remarks>
    /// <para>
    /// The ID values generated by this method should normally return the same value for the same
    /// component, for the same version of an application. This relies on the order of calls to this
    /// method being stable, and so will not produce stable results (for any component) if calls are
    /// made in a non-deterministic order (for instance, dynamically according to user input). It
    /// also will fail to produce stable results across code changes which add or remove invocations
    /// to this method. For truly stable ID values, manually-assigned IDs should always be
    /// preferred.
    /// </para>
    /// <para>
    /// THe IDs produced by this method prioritize brevity over true uniqueness, to ensure that IDs
    /// will not unnecessarily bloat URLs when used in query parameters. Under normal circumstances
    /// this method should not return any IDs which collide. The IDs that it generates also tend to
    /// <em>appear</em> random, in that they are unlikely to collide with manually-assigned IDs. But
    /// true uniqueness is not guaranteed in the way that it might be for, e.g. GUID values.
    /// </para>
    /// </remarks>
    public static string GenerateId(this ComponentBase component) => GenerateId(component.GetType().Name);

    /// <summary>
    /// Gets a semi-stable, reasonably unique ID values for components.
    /// </summary>
    /// <param name="typeName">The name of the type for which to obtain an ID.</param>
    /// <returns>
    /// A string containing an ID suitable for use in an HTML <c>id</c> attribute.
    /// </returns>
    /// <remarks>
    /// <para>
    /// The ID values generated by this method should normally return the same value for the same
    /// component, for the same version of an application. This relies on the order of calls to this
    /// method being stable, and so will not produce stable results (for any component) if calls are
    /// made in a non-deterministic order (for instance, dynamically according to user input). It
    /// also will fail to produce stable results across code changes which add or remove invocations
    /// to this method. For truly stable ID values, manually-assigned IDs should always be
    /// preferred.
    /// </para>
    /// <para>
    /// THe IDs produced by this method prioritize brevity over true uniqueness, to ensure that IDs
    /// will not unnecessarily bloat URLs when used in query parameters. Under normal circumstances
    /// this method should not return any IDs which collide. The IDs that it generates also tend to
    /// <em>appear</em> random, in that they are unlikely to collide with manually-assigned IDs. But
    /// true uniqueness is not guaranteed in the way that it might be for, e.g. GUID values.
    /// </para>
    /// </remarks>
    public static string GenerateId(string typeName)
    {
        if (!_typePrefixes.TryGetValue(typeName, out var prefix))
        {
            var length = 1;
            do
            {
                prefix = typeName[..Math.Min(typeName.Length, length++)]
                    .ToLowerInvariant();
                if (length > prefix.Length + 1)
                {
                    prefix += (length - prefix.Length - 1).ToString("x");
                }
            }
            while (_prefixTypes.TryGetValue(prefix, out var currentComponent)
                && !currentComponent.Equals(typeName, StringComparison.Ordinal));
            _typePrefixes.Add(typeName, prefix);
            _prefixTypes.Add(prefix, typeName);
        }

        var newCount = _prefixCount.TryGetValue(prefix, out var count)
            ? count + 1
            : 1;
        _prefixCount[prefix] = newCount;

        return $"{prefix}-{newCount:x}";
    }
}
